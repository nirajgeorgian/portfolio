"use strict";

function write(data, file, next) {
    return fs.writeFile(file, data, next || function(err) {
        return null !== err ? console.error(err) : null;
    });
}

function stream(data, res, header) {
    return setHeaders(res, "Content-Type", header) === !0 ? res.send(data) : null;
}

function sitemap(options) {
    return new Sitemap(options);
}

function Sitemap(options) {
    var resolve = require("path").resolve, opt = options || Object.create(null), http = "https" == opt.http ? "https://" : "http://", url = String(opt.url || "127.0.0.1"), port = isNaN(opt.port) ? "" : ":" + Number(opt.port);
    this.my = {
        url: http + url + port,
        sitemap: String(opt.sitemap || "sitemap.xml"),
        robots: String(opt.robots || "robots.txt"),
        route: "object" == typeof opt.route ? opt.route : Object.create(null),
        cache: Number(opt.cache) || !1,
        sitemapSubmission: !!opt.sitemapSubmission && String(opt.sitemapSubmission)
    }, this.my.sitemap = resolve(this.my.sitemap), this.my.robots = resolve(this.my.robots), 
    this.map = "object" == typeof opt.map ? opt.map : Object.create(null), this._XMLwork = this.xml, 
    this._TXTwork = this.txt, opt.cache && (this.cache = {
        xml: {
            timestamp: 0
        },
        txt: {
            timestamp: 0
        }
    }, this._XMLwork = this._XMLcache, this._TXTwork = this._TXTcache), opt.generate && this.generate(opt.generate);
}

var fs = require("fs"), setHeaders = require("setheaders").setWritableHeader;

module.exports = sitemap, Sitemap.prototype.generate = function(app, router, store) {
    if (app) if (app._router) {
        if (app._router.stack) return this.generate4(app, router, store);
        if (app._router.map) return this.generate3(app, router, store);
    } else if (app.stack) return this.generate4(app, router, store);
    throw new Error("missing express configuration");
}, Sitemap.prototype.generate4 = function(app, router, store) {
    for (var map = Object.create(null), routing = app._router ? app._router.stack : app.stack, i = 0, ii = routing.length; i < ii; ++i) {
        var route = routing[i];
        if (route.route) route = routing[i].route, route && route.methods && (route.methods.get || route.methods._all) && (map[route.path.toString()] = [ "get" ]); else if (route.handle && route.handle.stack && router) {
            for (var handle, j = 0, jj = router.length; j < jj; ++j) if (route.regexp.test(router[j])) {
                handle = router[j];
                break;
            }
            if (handle) {
                "/" === handle && (handle = "");
                var route = this.generate4(route.handle, router, !1);
                if (route) for (route = Object.keys(route), j = 0, jj = route.length; j < jj; ++j) map[handle + route[j]] = [ "get" ];
            }
        }
    }
    if (store !== !1) for (routing in map) this.map[routing] = map[routing];
    return map;
}, Sitemap.prototype.generate3 = function(app, router, store) {
    for (var map = Object.create(null), routing = app.routes.get, i = 0, ii = routing.length; i < ii; ++i) {
        var route = routing[i];
        route && route.path && (map[route.path.toString()] = [ "get" ]);
    }
    return store !== !1 && (this.map = map), map;
}, Sitemap.prototype.tickle = function() {
    if (global.tickle && global.tickle.route) {
        for (var route in global.tickle.route) this.map[route] = [];
        return this.map;
    }
    return Object.create(null);
}, Sitemap.prototype.reset = function() {
    var r = Object.create(null);
    return this.map = r, this.my.cache && (this.cache = {
        xml: {
            timestamp: 0
        },
        txt: {
            timestamp: 0
        }
    }), r;
}, Sitemap.prototype.xml = function() {
    var route = this.my.route, sitemap = this.map, head = '<?xml version="1.0" encoding="UTF-8"?>';
    head += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">';
    var lang = ' xmlns:xhtml="http://www.w3.org/1999/xhtml">', langFlag = !1, tail = "</urlset>", data = "";
    for (var uri in sitemap) {
        var rr = route.ALL || route[uri] || !1;
        if (!rr || !rr.disallow && !rr.hide) {
            if (data += "<url><loc>" + this.my.url + uri + "</loc>", "object" == typeof rr && (rr.lastmod && (data += "<lastmod>" + rr.lastmod + "</lastmod>"), 
            rr.changefreq && (data += "<changefreq>" + rr.changefreq + "</changefreq>"), rr.priority && (data += "<priority>" + rr.priority + "</priority>"), 
            rr.alternatepages)) {
                langFlag = !0;
                var pages = rr.alternatepages;
                for (var position in pages) {
                    data += "<xhtml:link";
                    for (var attribute in pages[position]) "rel" === attribute && (data += ' rel="' + pages[position][attribute] + '"'), 
                    "hreflang" === attribute && (data += ' hreflang="' + pages[position][attribute] + '"'), 
                    "href" === attribute && (data += ' href="' + pages[position][attribute] + '"');
                    data += " />";
                }
            }
            data += "</url>";
        }
    }
    return langFlag === !0 && (head = head.substr(0, head.length - 1) + lang), head + data + tail;
}, Sitemap.prototype.txt = function() {
    var temp = !0, route = this.my.route, sitemap = this.map, data = "User-agent: *\n";
    for (var uri in sitemap) {
        var rr = route[uri];
        if (route.ALL && route.ALL.disallow && !route.ALL.hide) {
            temp = !1, data += "Disallow: /\n";
            break;
        }
        rr && rr.disallow && !rr.hide && (temp = !1, data += "Disallow: " + uri + "\n");
    }
    return temp && (data += "Disallow: \n"), this.my.sitemapSubmission && (data += "Sitemap: " + this.my.url + this.my.sitemapSubmission), 
    data;
}, Sitemap.prototype.XMLtoFile = function(path, next) {
    return write(this._XMLwork(), path || this.my.sitemap, next);
}, Sitemap.prototype.TXTtoFile = function(path, next) {
    return write(this._TXTwork(), path || this.my.robots, next);
}, Sitemap.prototype.toFile = function(next) {
    write(this._XMLwork(), this.my.sitemap, next), write(this._TXTwork(), this.my.robots, next);
}, Sitemap.prototype.XMLtoWeb = function(res) {
    return stream(this._XMLwork(), res, "application/xml");
}, Sitemap.prototype.TXTtoWeb = function(res) {
    return stream(this._TXTwork(), res, "text/plain");
}, Sitemap.prototype._XMLcache = function() {
    if (this.cache.xml.timestamp - Date.now() > 0) return this.cache.xml.data;
    var data = this.xml();
    return this.cache.xml = {
        timestamp: Date.now() + this.my.cache,
        data: data
    }, data;
}, Sitemap.prototype._TXTcache = function() {
    if (this.cache.txt.timestamp - Date.now() > 0) return this.cache.txt.data;
    var data = this.txt();
    return this.cache.txt = {
        timestamp: Date.now() + this.my.cache,
        data: data
    }, data;
};
